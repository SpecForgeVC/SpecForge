// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: requirements.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createRequirement = `-- name: CreateRequirement :one
INSERT INTO requirements (
    roadmap_item_id, title, description, testable, acceptance_criteria, order_index
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, roadmap_item_id, title, description, testable, acceptance_criteria, order_index
`

type CreateRequirementParams struct {
	RoadmapItemID      uuid.UUID      `json:"roadmap_item_id"`
	Title              string         `json:"title"`
	Description        sql.NullString `json:"description"`
	Testable           sql.NullBool   `json:"testable"`
	AcceptanceCriteria sql.NullString `json:"acceptance_criteria"`
	OrderIndex         sql.NullInt32  `json:"order_index"`
}

func (q *Queries) CreateRequirement(ctx context.Context, arg CreateRequirementParams) (Requirement, error) {
	row := q.db.QueryRowContext(ctx, createRequirement,
		arg.RoadmapItemID,
		arg.Title,
		arg.Description,
		arg.Testable,
		arg.AcceptanceCriteria,
		arg.OrderIndex,
	)
	var i Requirement
	err := row.Scan(
		&i.ID,
		&i.RoadmapItemID,
		&i.Title,
		&i.Description,
		&i.Testable,
		&i.AcceptanceCriteria,
		&i.OrderIndex,
	)
	return i, err
}

const deleteRequirement = `-- name: DeleteRequirement :exec
DELETE FROM requirements WHERE id = $1
`

func (q *Queries) DeleteRequirement(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRequirement, id)
	return err
}

const getRequirement = `-- name: GetRequirement :one
SELECT id, roadmap_item_id, title, description, testable, acceptance_criteria, order_index FROM requirements WHERE id = $1
`

func (q *Queries) GetRequirement(ctx context.Context, id uuid.UUID) (Requirement, error) {
	row := q.db.QueryRowContext(ctx, getRequirement, id)
	var i Requirement
	err := row.Scan(
		&i.ID,
		&i.RoadmapItemID,
		&i.Title,
		&i.Description,
		&i.Testable,
		&i.AcceptanceCriteria,
		&i.OrderIndex,
	)
	return i, err
}

const listRequirementsByRoadmapItem = `-- name: ListRequirementsByRoadmapItem :many
SELECT id, roadmap_item_id, title, description, testable, acceptance_criteria, order_index FROM requirements WHERE roadmap_item_id = $1 ORDER BY order_index ASC
`

func (q *Queries) ListRequirementsByRoadmapItem(ctx context.Context, roadmapItemID uuid.UUID) ([]Requirement, error) {
	rows, err := q.db.QueryContext(ctx, listRequirementsByRoadmapItem, roadmapItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Requirement
	for rows.Next() {
		var i Requirement
		if err := rows.Scan(
			&i.ID,
			&i.RoadmapItemID,
			&i.Title,
			&i.Description,
			&i.Testable,
			&i.AcceptanceCriteria,
			&i.OrderIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRequirement = `-- name: UpdateRequirement :one
UPDATE requirements SET
    title = $2,
    description = $3,
    testable = $4,
    acceptance_criteria = $5,
    order_index = $6
WHERE id = $1
RETURNING id, roadmap_item_id, title, description, testable, acceptance_criteria, order_index
`

type UpdateRequirementParams struct {
	ID                 uuid.UUID      `json:"id"`
	Title              string         `json:"title"`
	Description        sql.NullString `json:"description"`
	Testable           sql.NullBool   `json:"testable"`
	AcceptanceCriteria sql.NullString `json:"acceptance_criteria"`
	OrderIndex         sql.NullInt32  `json:"order_index"`
}

func (q *Queries) UpdateRequirement(ctx context.Context, arg UpdateRequirementParams) (Requirement, error) {
	row := q.db.QueryRowContext(ctx, updateRequirement,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Testable,
		arg.AcceptanceCriteria,
		arg.OrderIndex,
	)
	var i Requirement
	err := row.Scan(
		&i.ID,
		&i.RoadmapItemID,
		&i.Title,
		&i.Description,
		&i.Testable,
		&i.AcceptanceCriteria,
		&i.OrderIndex,
	)
	return i, err
}
