// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: feature_intelligence.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createFeatureIntelligence = `-- name: CreateFeatureIntelligence :one
INSERT INTO feature_intelligence (
    feature_id,
    completeness_score,
    contract_integrity_score,
    variable_coverage_score,
    dependency_stability_score,
    drift_risk_score,
    test_coverage_score,
    llm_confidence_score,
    overall_score
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, feature_id, completeness_score, contract_integrity_score, variable_coverage_score, dependency_stability_score, drift_risk_score, test_coverage_score, llm_confidence_score, overall_score, last_calculated_at
`

type CreateFeatureIntelligenceParams struct {
	FeatureID                uuid.UUID `json:"feature_id"`
	CompletenessScore        int32     `json:"completeness_score"`
	ContractIntegrityScore   int32     `json:"contract_integrity_score"`
	VariableCoverageScore    int32     `json:"variable_coverage_score"`
	DependencyStabilityScore int32     `json:"dependency_stability_score"`
	DriftRiskScore           int32     `json:"drift_risk_score"`
	TestCoverageScore        int32     `json:"test_coverage_score"`
	LlmConfidenceScore       int32     `json:"llm_confidence_score"`
	OverallScore             int32     `json:"overall_score"`
}

func (q *Queries) CreateFeatureIntelligence(ctx context.Context, arg CreateFeatureIntelligenceParams) (FeatureIntelligence, error) {
	row := q.db.QueryRowContext(ctx, createFeatureIntelligence,
		arg.FeatureID,
		arg.CompletenessScore,
		arg.ContractIntegrityScore,
		arg.VariableCoverageScore,
		arg.DependencyStabilityScore,
		arg.DriftRiskScore,
		arg.TestCoverageScore,
		arg.LlmConfidenceScore,
		arg.OverallScore,
	)
	var i FeatureIntelligence
	err := row.Scan(
		&i.ID,
		&i.FeatureID,
		&i.CompletenessScore,
		&i.ContractIntegrityScore,
		&i.VariableCoverageScore,
		&i.DependencyStabilityScore,
		&i.DriftRiskScore,
		&i.TestCoverageScore,
		&i.LlmConfidenceScore,
		&i.OverallScore,
		&i.LastCalculatedAt,
	)
	return i, err
}

const deleteFeatureIntelligence = `-- name: DeleteFeatureIntelligence :exec
DELETE FROM feature_intelligence
WHERE feature_id = $1
`

func (q *Queries) DeleteFeatureIntelligence(ctx context.Context, featureID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteFeatureIntelligence, featureID)
	return err
}

const getFeatureIntelligence = `-- name: GetFeatureIntelligence :one
SELECT id, feature_id, completeness_score, contract_integrity_score, variable_coverage_score, dependency_stability_score, drift_risk_score, test_coverage_score, llm_confidence_score, overall_score, last_calculated_at FROM feature_intelligence
WHERE feature_id = $1
`

func (q *Queries) GetFeatureIntelligence(ctx context.Context, featureID uuid.UUID) (FeatureIntelligence, error) {
	row := q.db.QueryRowContext(ctx, getFeatureIntelligence, featureID)
	var i FeatureIntelligence
	err := row.Scan(
		&i.ID,
		&i.FeatureID,
		&i.CompletenessScore,
		&i.ContractIntegrityScore,
		&i.VariableCoverageScore,
		&i.DependencyStabilityScore,
		&i.DriftRiskScore,
		&i.TestCoverageScore,
		&i.LlmConfidenceScore,
		&i.OverallScore,
		&i.LastCalculatedAt,
	)
	return i, err
}

const updateFeatureIntelligence = `-- name: UpdateFeatureIntelligence :one
UPDATE feature_intelligence
SET
    completeness_score = $2,
    contract_integrity_score = $3,
    variable_coverage_score = $4,
    dependency_stability_score = $5,
    drift_risk_score = $6,
    test_coverage_score = $7,
    llm_confidence_score = $8,
    overall_score = $9,
    last_calculated_at = NOW()
WHERE feature_id = $1
RETURNING id, feature_id, completeness_score, contract_integrity_score, variable_coverage_score, dependency_stability_score, drift_risk_score, test_coverage_score, llm_confidence_score, overall_score, last_calculated_at
`

type UpdateFeatureIntelligenceParams struct {
	FeatureID                uuid.UUID `json:"feature_id"`
	CompletenessScore        int32     `json:"completeness_score"`
	ContractIntegrityScore   int32     `json:"contract_integrity_score"`
	VariableCoverageScore    int32     `json:"variable_coverage_score"`
	DependencyStabilityScore int32     `json:"dependency_stability_score"`
	DriftRiskScore           int32     `json:"drift_risk_score"`
	TestCoverageScore        int32     `json:"test_coverage_score"`
	LlmConfidenceScore       int32     `json:"llm_confidence_score"`
	OverallScore             int32     `json:"overall_score"`
}

func (q *Queries) UpdateFeatureIntelligence(ctx context.Context, arg UpdateFeatureIntelligenceParams) (FeatureIntelligence, error) {
	row := q.db.QueryRowContext(ctx, updateFeatureIntelligence,
		arg.FeatureID,
		arg.CompletenessScore,
		arg.ContractIntegrityScore,
		arg.VariableCoverageScore,
		arg.DependencyStabilityScore,
		arg.DriftRiskScore,
		arg.TestCoverageScore,
		arg.LlmConfidenceScore,
		arg.OverallScore,
	)
	var i FeatureIntelligence
	err := row.Scan(
		&i.ID,
		&i.FeatureID,
		&i.CompletenessScore,
		&i.ContractIntegrityScore,
		&i.VariableCoverageScore,
		&i.DependencyStabilityScore,
		&i.DriftRiskScore,
		&i.TestCoverageScore,
		&i.LlmConfidenceScore,
		&i.OverallScore,
		&i.LastCalculatedAt,
	)
	return i, err
}
