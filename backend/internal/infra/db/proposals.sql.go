// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: proposals.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const createAiProposal = `-- name: CreateAiProposal :one
INSERT INTO ai_proposals (
    roadmap_item_id, proposal_type, diff, reasoning, confidence_score, status
) VALUES (
    $1, $2, $3, $4, $5, 'PENDING'
)
RETURNING id, roadmap_item_id, proposal_type, diff, reasoning, confidence_score, status, reviewed_by, created_at
`

type CreateAiProposalParams struct {
	RoadmapItemID   uuid.UUID       `json:"roadmap_item_id"`
	ProposalType    ProposalType    `json:"proposal_type"`
	Diff            json.RawMessage `json:"diff"`
	Reasoning       sql.NullString  `json:"reasoning"`
	ConfidenceScore sql.NullFloat64 `json:"confidence_score"`
}

func (q *Queries) CreateAiProposal(ctx context.Context, arg CreateAiProposalParams) (AiProposal, error) {
	row := q.db.QueryRowContext(ctx, createAiProposal,
		arg.RoadmapItemID,
		arg.ProposalType,
		arg.Diff,
		arg.Reasoning,
		arg.ConfidenceScore,
	)
	var i AiProposal
	err := row.Scan(
		&i.ID,
		&i.RoadmapItemID,
		&i.ProposalType,
		&i.Diff,
		&i.Reasoning,
		&i.ConfidenceScore,
		&i.Status,
		&i.ReviewedBy,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAiProposal = `-- name: DeleteAiProposal :exec
DELETE FROM ai_proposals
WHERE id = $1
`

func (q *Queries) DeleteAiProposal(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAiProposal, id)
	return err
}

const getAiProposal = `-- name: GetAiProposal :one
SELECT id, roadmap_item_id, proposal_type, diff, reasoning, confidence_score, status, reviewed_by, created_at FROM ai_proposals
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAiProposal(ctx context.Context, id uuid.UUID) (AiProposal, error) {
	row := q.db.QueryRowContext(ctx, getAiProposal, id)
	var i AiProposal
	err := row.Scan(
		&i.ID,
		&i.RoadmapItemID,
		&i.ProposalType,
		&i.Diff,
		&i.Reasoning,
		&i.ConfidenceScore,
		&i.Status,
		&i.ReviewedBy,
		&i.CreatedAt,
	)
	return i, err
}

const listAiProposalsByProject = `-- name: ListAiProposalsByProject :many
SELECT id, roadmap_item_id, proposal_type, diff, reasoning, confidence_score, status, reviewed_by, created_at FROM ai_proposals
WHERE roadmap_item_id IN (
    SELECT id FROM roadmap_items WHERE project_id = $1
)
ORDER BY created_at DESC
`

func (q *Queries) ListAiProposalsByProject(ctx context.Context, projectID uuid.UUID) ([]AiProposal, error) {
	rows, err := q.db.QueryContext(ctx, listAiProposalsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiProposal
	for rows.Next() {
		var i AiProposal
		if err := rows.Scan(
			&i.ID,
			&i.RoadmapItemID,
			&i.ProposalType,
			&i.Diff,
			&i.Reasoning,
			&i.ConfidenceScore,
			&i.Status,
			&i.ReviewedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAiProposalsByRoadmapItem = `-- name: ListAiProposalsByRoadmapItem :many
SELECT id, roadmap_item_id, proposal_type, diff, reasoning, confidence_score, status, reviewed_by, created_at FROM ai_proposals
WHERE roadmap_item_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAiProposalsByRoadmapItem(ctx context.Context, roadmapItemID uuid.UUID) ([]AiProposal, error) {
	rows, err := q.db.QueryContext(ctx, listAiProposalsByRoadmapItem, roadmapItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AiProposal
	for rows.Next() {
		var i AiProposal
		if err := rows.Scan(
			&i.ID,
			&i.RoadmapItemID,
			&i.ProposalType,
			&i.Diff,
			&i.Reasoning,
			&i.ConfidenceScore,
			&i.Status,
			&i.ReviewedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAiProposalStatus = `-- name: UpdateAiProposalStatus :one
UPDATE ai_proposals
SET status = $2, reviewed_by = $3
WHERE id = $1
RETURNING id, roadmap_item_id, proposal_type, diff, reasoning, confidence_score, status, reviewed_by, created_at
`

type UpdateAiProposalStatusParams struct {
	ID         uuid.UUID          `json:"id"`
	Status     NullProposalStatus `json:"status"`
	ReviewedBy uuid.NullUUID      `json:"reviewed_by"`
}

func (q *Queries) UpdateAiProposalStatus(ctx context.Context, arg UpdateAiProposalStatusParams) (AiProposal, error) {
	row := q.db.QueryRowContext(ctx, updateAiProposalStatus, arg.ID, arg.Status, arg.ReviewedBy)
	var i AiProposal
	err := row.Scan(
		&i.ID,
		&i.RoadmapItemID,
		&i.ProposalType,
		&i.Diff,
		&i.Reasoning,
		&i.ConfidenceScore,
		&i.Status,
		&i.ReviewedBy,
		&i.CreatedAt,
	)
	return i, err
}
