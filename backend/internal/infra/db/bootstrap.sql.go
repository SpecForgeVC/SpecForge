// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bootstrap.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const getIntelligenceSnapshot = `-- name: GetIntelligenceSnapshot :one
SELECT id, project_id, version, snapshot_json, architecture_score, contract_density, risk_score, alignment_score, confidence_json, created_at FROM project_intelligence_snapshots
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetIntelligenceSnapshot(ctx context.Context, id uuid.UUID) (ProjectIntelligenceSnapshot, error) {
	row := q.db.QueryRowContext(ctx, getIntelligenceSnapshot, id)
	var i ProjectIntelligenceSnapshot
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Version,
		&i.SnapshotJson,
		&i.ArchitectureScore,
		&i.ContractDensity,
		&i.RiskScore,
		&i.AlignmentScore,
		&i.ConfidenceJson,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestSnapshot = `-- name: GetLatestSnapshot :one
SELECT id, project_id, version, snapshot_json, architecture_score, contract_density, risk_score, alignment_score, confidence_json, created_at FROM project_intelligence_snapshots
WHERE project_id = $1
ORDER BY version DESC
LIMIT 1
`

func (q *Queries) GetLatestSnapshot(ctx context.Context, projectID uuid.UUID) (ProjectIntelligenceSnapshot, error) {
	row := q.db.QueryRowContext(ctx, getLatestSnapshot, projectID)
	var i ProjectIntelligenceSnapshot
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Version,
		&i.SnapshotJson,
		&i.ArchitectureScore,
		&i.ContractDensity,
		&i.RiskScore,
		&i.AlignmentScore,
		&i.ConfidenceJson,
		&i.CreatedAt,
	)
	return i, err
}

const getMaxSnapshotVersion = `-- name: GetMaxSnapshotVersion :one
SELECT COALESCE(MAX(version), 0)::int AS max_version
FROM project_intelligence_snapshots
WHERE project_id = $1
`

func (q *Queries) GetMaxSnapshotVersion(ctx context.Context, projectID uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, getMaxSnapshotVersion, projectID)
	var max_version int32
	err := row.Scan(&max_version)
	return max_version, err
}

const insertIntelligenceSnapshot = `-- name: InsertIntelligenceSnapshot :one
INSERT INTO project_intelligence_snapshots (
  project_id, version, snapshot_json, architecture_score, contract_density, risk_score, alignment_score, confidence_json
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, project_id, version, snapshot_json, architecture_score, contract_density, risk_score, alignment_score, confidence_json, created_at
`

type InsertIntelligenceSnapshotParams struct {
	ProjectID         uuid.UUID             `json:"project_id"`
	Version           int32                 `json:"version"`
	SnapshotJson      json.RawMessage       `json:"snapshot_json"`
	ArchitectureScore sql.NullString        `json:"architecture_score"`
	ContractDensity   sql.NullString        `json:"contract_density"`
	RiskScore         sql.NullString        `json:"risk_score"`
	AlignmentScore    sql.NullString        `json:"alignment_score"`
	ConfidenceJson    pqtype.NullRawMessage `json:"confidence_json"`
}

func (q *Queries) InsertIntelligenceSnapshot(ctx context.Context, arg InsertIntelligenceSnapshotParams) (ProjectIntelligenceSnapshot, error) {
	row := q.db.QueryRowContext(ctx, insertIntelligenceSnapshot,
		arg.ProjectID,
		arg.Version,
		arg.SnapshotJson,
		arg.ArchitectureScore,
		arg.ContractDensity,
		arg.RiskScore,
		arg.AlignmentScore,
		arg.ConfidenceJson,
	)
	var i ProjectIntelligenceSnapshot
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Version,
		&i.SnapshotJson,
		&i.ArchitectureScore,
		&i.ContractDensity,
		&i.RiskScore,
		&i.AlignmentScore,
		&i.ConfidenceJson,
		&i.CreatedAt,
	)
	return i, err
}

const insertProjectApiEntry = `-- name: InsertProjectApiEntry :one
INSERT INTO project_api_index (
  project_id, snapshot_id, endpoint, method, auth_type, request_schema, response_schema
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, project_id, snapshot_id, endpoint, method, auth_type, request_schema, response_schema
`

type InsertProjectApiEntryParams struct {
	ProjectID      uuid.UUID             `json:"project_id"`
	SnapshotID     uuid.UUID             `json:"snapshot_id"`
	Endpoint       string                `json:"endpoint"`
	Method         string                `json:"method"`
	AuthType       sql.NullString        `json:"auth_type"`
	RequestSchema  pqtype.NullRawMessage `json:"request_schema"`
	ResponseSchema pqtype.NullRawMessage `json:"response_schema"`
}

func (q *Queries) InsertProjectApiEntry(ctx context.Context, arg InsertProjectApiEntryParams) (ProjectApiIndex, error) {
	row := q.db.QueryRowContext(ctx, insertProjectApiEntry,
		arg.ProjectID,
		arg.SnapshotID,
		arg.Endpoint,
		arg.Method,
		arg.AuthType,
		arg.RequestSchema,
		arg.ResponseSchema,
	)
	var i ProjectApiIndex
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SnapshotID,
		&i.Endpoint,
		&i.Method,
		&i.AuthType,
		&i.RequestSchema,
		&i.ResponseSchema,
	)
	return i, err
}

const insertProjectContractEntry = `-- name: InsertProjectContractEntry :one
INSERT INTO project_contract_registry (
  project_id, snapshot_id, name, contract_type, schema_json, source_module, stability_score
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, project_id, snapshot_id, name, contract_type, schema_json, source_module, stability_score
`

type InsertProjectContractEntryParams struct {
	ProjectID      uuid.UUID             `json:"project_id"`
	SnapshotID     uuid.UUID             `json:"snapshot_id"`
	Name           string                `json:"name"`
	ContractType   sql.NullString        `json:"contract_type"`
	SchemaJson     pqtype.NullRawMessage `json:"schema_json"`
	SourceModule   sql.NullString        `json:"source_module"`
	StabilityScore sql.NullString        `json:"stability_score"`
}

func (q *Queries) InsertProjectContractEntry(ctx context.Context, arg InsertProjectContractEntryParams) (ProjectContractRegistry, error) {
	row := q.db.QueryRowContext(ctx, insertProjectContractEntry,
		arg.ProjectID,
		arg.SnapshotID,
		arg.Name,
		arg.ContractType,
		arg.SchemaJson,
		arg.SourceModule,
		arg.StabilityScore,
	)
	var i ProjectContractRegistry
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SnapshotID,
		&i.Name,
		&i.ContractType,
		&i.SchemaJson,
		&i.SourceModule,
		&i.StabilityScore,
	)
	return i, err
}

const insertProjectEntity = `-- name: InsertProjectEntity :one
INSERT INTO project_entities (
  project_id, snapshot_id, name, relationships_json, constraints_json
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, project_id, snapshot_id, name, relationships_json, constraints_json
`

type InsertProjectEntityParams struct {
	ProjectID         uuid.UUID             `json:"project_id"`
	SnapshotID        uuid.UUID             `json:"snapshot_id"`
	Name              string                `json:"name"`
	RelationshipsJson pqtype.NullRawMessage `json:"relationships_json"`
	ConstraintsJson   pqtype.NullRawMessage `json:"constraints_json"`
}

func (q *Queries) InsertProjectEntity(ctx context.Context, arg InsertProjectEntityParams) (ProjectEntity, error) {
	row := q.db.QueryRowContext(ctx, insertProjectEntity,
		arg.ProjectID,
		arg.SnapshotID,
		arg.Name,
		arg.RelationshipsJson,
		arg.ConstraintsJson,
	)
	var i ProjectEntity
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SnapshotID,
		&i.Name,
		&i.RelationshipsJson,
		&i.ConstraintsJson,
	)
	return i, err
}

const insertProjectModule = `-- name: InsertProjectModule :one
INSERT INTO project_modules (
  project_id, snapshot_id, name, description, risk_level, change_sensitivity
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, project_id, snapshot_id, name, description, risk_level, change_sensitivity
`

type InsertProjectModuleParams struct {
	ProjectID         uuid.UUID      `json:"project_id"`
	SnapshotID        uuid.UUID      `json:"snapshot_id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	RiskLevel         sql.NullString `json:"risk_level"`
	ChangeSensitivity sql.NullString `json:"change_sensitivity"`
}

func (q *Queries) InsertProjectModule(ctx context.Context, arg InsertProjectModuleParams) (ProjectModule, error) {
	row := q.db.QueryRowContext(ctx, insertProjectModule,
		arg.ProjectID,
		arg.SnapshotID,
		arg.Name,
		arg.Description,
		arg.RiskLevel,
		arg.ChangeSensitivity,
	)
	var i ProjectModule
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SnapshotID,
		&i.Name,
		&i.Description,
		&i.RiskLevel,
		&i.ChangeSensitivity,
	)
	return i, err
}

const listApiEntriesBySnapshot = `-- name: ListApiEntriesBySnapshot :many
SELECT id, project_id, snapshot_id, endpoint, method, auth_type, request_schema, response_schema FROM project_api_index
WHERE snapshot_id = $1
ORDER BY endpoint
`

func (q *Queries) ListApiEntriesBySnapshot(ctx context.Context, snapshotID uuid.UUID) ([]ProjectApiIndex, error) {
	rows, err := q.db.QueryContext(ctx, listApiEntriesBySnapshot, snapshotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectApiIndex
	for rows.Next() {
		var i ProjectApiIndex
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SnapshotID,
			&i.Endpoint,
			&i.Method,
			&i.AuthType,
			&i.RequestSchema,
			&i.ResponseSchema,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContractEntriesBySnapshot = `-- name: ListContractEntriesBySnapshot :many
SELECT id, project_id, snapshot_id, name, contract_type, schema_json, source_module, stability_score FROM project_contract_registry
WHERE snapshot_id = $1
ORDER BY name
`

func (q *Queries) ListContractEntriesBySnapshot(ctx context.Context, snapshotID uuid.UUID) ([]ProjectContractRegistry, error) {
	rows, err := q.db.QueryContext(ctx, listContractEntriesBySnapshot, snapshotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectContractRegistry
	for rows.Next() {
		var i ProjectContractRegistry
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SnapshotID,
			&i.Name,
			&i.ContractType,
			&i.SchemaJson,
			&i.SourceModule,
			&i.StabilityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntitiesBySnapshot = `-- name: ListEntitiesBySnapshot :many
SELECT id, project_id, snapshot_id, name, relationships_json, constraints_json FROM project_entities
WHERE snapshot_id = $1
ORDER BY name
`

func (q *Queries) ListEntitiesBySnapshot(ctx context.Context, snapshotID uuid.UUID) ([]ProjectEntity, error) {
	rows, err := q.db.QueryContext(ctx, listEntitiesBySnapshot, snapshotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectEntity
	for rows.Next() {
		var i ProjectEntity
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SnapshotID,
			&i.Name,
			&i.RelationshipsJson,
			&i.ConstraintsJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModulesBySnapshot = `-- name: ListModulesBySnapshot :many
SELECT id, project_id, snapshot_id, name, description, risk_level, change_sensitivity FROM project_modules
WHERE snapshot_id = $1
ORDER BY name
`

func (q *Queries) ListModulesBySnapshot(ctx context.Context, snapshotID uuid.UUID) ([]ProjectModule, error) {
	rows, err := q.db.QueryContext(ctx, listModulesBySnapshot, snapshotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectModule
	for rows.Next() {
		var i ProjectModule
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SnapshotID,
			&i.Name,
			&i.Description,
			&i.RiskLevel,
			&i.ChangeSensitivity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSnapshotsByProject = `-- name: ListSnapshotsByProject :many
SELECT id, project_id, version, snapshot_json, architecture_score, contract_density, risk_score, alignment_score, confidence_json, created_at FROM project_intelligence_snapshots
WHERE project_id = $1
ORDER BY version DESC
`

func (q *Queries) ListSnapshotsByProject(ctx context.Context, projectID uuid.UUID) ([]ProjectIntelligenceSnapshot, error) {
	rows, err := q.db.QueryContext(ctx, listSnapshotsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectIntelligenceSnapshot
	for rows.Next() {
		var i ProjectIntelligenceSnapshot
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Version,
			&i.SnapshotJson,
			&i.ArchitectureScore,
			&i.ContractDensity,
			&i.RiskScore,
			&i.AlignmentScore,
			&i.ConfidenceJson,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
